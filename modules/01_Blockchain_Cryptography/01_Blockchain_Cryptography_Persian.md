به بوت‌کمپ توسعه‌دهندگان اتریوم در دانشگاه Alchemy خوش آمدید! این برگه تقلب، مفاهیم اساسی فناوری بلاک‌چین را با تمرکز بر اتریوم، قراردادهای هوشمند و سازوکارهای رمزنگاری خلاصه می‌کند.

---

## 📚 بلاک‌چین‌ها

### 🎯 هدف از یک بلاک‌چین

- ایجاد یک **شبکه از رایانه‌ها** که بر روی **وضعیت مشترک داده‌ها** توافق دارند.
- مشارکت باید برای **هر فرد یا سازمانی** آزاد باشد.
- هیچ موجودیت واحدی نباید بتواند کنترل فرآیند را در دست بگیرد.
- این فرآیند توافق، **اجماع (Consensus)** نامیده می‌شود.

---

## 💸 کاربرد ارز دیجیتال

### چرا به بلاک‌چین نیاز داریم؟

یک ارز دیجیتال ساده که بلاک‌چین ندارد به یک **دفترکل متمرکز** وابسته است و مشکلاتی ایجاد می‌کند:

1. اعتماد به متولی دفتر (مقاومت در برابر تقلب یا رشوه).
2. در دسترس بودن اطلاعات و به‌روزرسانی مداوم موجودی‌ها.
3. مقیاس‌پذیری با افزایش تعداد شرکت‌کنندگان.

بلاک‌چین با استفاده از **غیرمتمرکزسازی و رمزنگاری**، **مشکل شماره ۱ — اعتماد** را حل می‌کند.

### 🔍 پیشرفت انقلابی

- در سال ۲۰۰۸، **ساتوشی ناکاموتو** بیت‌کوین را پیشنهاد داد.
- بیت‌کوین یک سیستم **مبادله ارزش همتا به همتا** را توصیف کرد.
- این سیستم از **رمزنگاری و نظریه بازی‌ها** برای تشویق به رفتار صادقانه استفاده کرد.
- داده‌ها در **زنجیره‌ای از بلوک‌های به‌هم‌مرتبط رمزنگاری‌شده** ذخیره شدند؛ از این رو اصطلاح **بلاک‌چین** شکل گرفت.

---

## 🧠 بلاک‌چین‌های قرارداد هوشمند

قراردادهای هوشمند امکان اجرای **کد روی یک شبکه غیرمتمرکز** را فراهم می‌کنند که باعث می‌شود:

- **مقاوم در برابر سانسور**
- **در دسترس عموم**
- **شفاف و قابل راستی‌آزمایی** باشند.

### نمونه: قرارداد هوشمند Solidity

    // این ساختار داده مشخص می‌کند که هر آدرس چه موجودی‌ای دارد
    mapping(address => uint) balances;

    function transfer(address to, uint amount) external {
      // مقدار را از موجودی فرستنده کم کن
      balances[msg.sender] -= amount;

      // مقدار را به موجودی گیرنده اضافه کن
      balances[to] += amount;
    }

- این تابع، نسخه‌ای پایه‌ای از تابع `transfer()` در استاندارد ERC20 است.
- **چیزی خاصی** در مورد آن نیست تا زمانی که روی **بلاک‌چین مستقر شود**.
- پس از استقرار، اجرای آن توسط **تمام گره‌های شبکه تضمین می‌شود**.

---

## 🔐 توابع هش رمزنگاری‌شده

### تابع هش چیست؟

یک **تابع هش** ورودی با هر اندازه‌ای را گرفته و یک **خروجی با اندازه ثابت** بازمی‌گرداند.

| ورودی                | اندازه ورودی       | خروجی (هش)    | اندازه خروجی |
|----------------------|---------------------|----------------|---------------|
| `52`                 | ۸ بایت              | `0x41cf...`    | ۳۲ بایت       |
| `"happy times"`      | ۲۲ بایت             | `0xd6bf...`    | ۳۲ بایت       |
| `monalisa.jpg`       | ۸۷۵۰۰۰ بایت         | `0x7cde...`    | ۳۲ بایت       |
| `worldseries.mp4`    | ۱۶٬۰۰۰٬۰۰۰٬۰۰۰ بایت | `0x9c0e...`    | ۳۲ بایت       |

### 🔒 ویژگی‌های تابع هش رمزنگاری‌شده

1. **قطعی**: ورودی یکسان → خروجی یکسان
2. **شبه‌تصادفی**: خروجی‌ها به‌نظر تصادفی و غیرقابل پیش‌بینی هستند
3. **یک‌طرفه**: بازگرداندن ورودی از روی خروجی تقریباً غیرممکن است
4. **محاسبه سریع**: انجام محاسبه به‌صورت کارآمد
5. **مقاوم در برابر برخورد**: بسیار بعید است که دو ورودی مختلف، خروجی یکسانی تولید کنند

> چالش: از یک [ابزار SHA-256](https://emn178.github.io/online-tools/sha256.html) استفاده کرده و این ویژگی‌ها را تست کنید!

### 🧠 چرا هش در بلاک‌چین مهم است؟

- **صرفه‌جویی در فضا**: به‌جای ذخیره ورودی‌های بزرگ، تنها هش ذخیره می‌شود.
- **امکان اعتبارسنجی**: تأیید داده بدون نیاز به ذخیره کامل آن.
- **پایه‌ای برای اجماع**: بخش اصلی سیستم‌های اثبات کار (Proof of Work).

---

## 🧩 جمع‌بندی

- **بلاک‌چین**: دفترکل غیرمتمرکز برای اجماع بدون نیاز به اعتماد.
- **ارز دیجیتال**: اولین کاربرد اصلی بلاک‌چین.
- **قراردادهای هوشمند**: منطق غیرمتمرکز برای اعمال قوانین مالی و برنامه‌ای.
- **توابع هش رمزنگاری‌شده**: جزء ضروری برای امنیت، ذخیره‌سازی و اجماع.

---

# برگه تقلب رمزنگاری کلید عمومی

---

## 🔐 تاریخچه رمزنگاری

- تا دهه ۱۹۷۰، تمرکز رمزنگاری بر **رمزگذاری پیام‌ها** برای حفظ محرمانگی بود.
- پیام‌ها با اعمال توابع ساده رمزگذاری می‌شدند، مثلاً جابجایی حروف ("abc" → "bcd").
- رمزنگاری اولیه با افشای روش، **به‌راحتی قابل شکستن** بود.
- معرفی **کلیدهای محرمانه** به دو طرف اجازه داد قبل از ارتباط، کلیدی مشترک تعیین کنند.
- این روش **رمزنگاری با کلید متقارن (Symmetric-Key Cryptography)** نام دارد: هر دو طرف از یک کلید استفاده می‌کنند.
- رمزنگاری در گذر زمان با روش‌های پیچیده‌تری توسعه یافت.

---

## 🖥️ رایانه‌های شخصی و چالش‌های جدید

- با ظهور رایانه‌های شخصی، سوالی مهم مطرح شد: **چگونه بدون تبادل قبلی کلید، ارتباط امن برقرار کنیم؟**
- ملاقات حضوری برای تبادل کلید در بسیاری موارد عملی نبود.
- در سال ۱۹۷۶، **ویتفیلد دیفی (Whitfield Diffie)** ایده‌ی **کلید عمومی** را پیشنهاد داد.
- در ابتدا بسیاری این ایده را رد کردند، چون تصور می‌شد کلید باید همواره محرمانه بماند.

---

## 💡 آزمایش ذهنی: کلید عمومی و خصوصی

- یک جفت کلید وجود دارد: **کلید خصوصی** و **کلید عمومی**.
- هر یک از این کلیدها می‌تواند پیامی را که با دیگری رمزگذاری شده، **رمزگشایی** کند.
- باب کلید عمومی‌اش را منتشر می‌کند، ولی کلید خصوصی‌اش را محرمانه نگه می‌دارد.

### امضاهای دیجیتال (اثبات منشأ)

- باب پیامی را با **کلید خصوصی** خود رمزگذاری می‌کند.
- هر کسی می‌تواند آن را با **کلید عمومی** باب رمزگشایی کند.
- تنها باب می‌توانسته پیام را ایجاد کند — این همان **امضای دیجیتال** است.

### پیام‌های محرمانه

- هر کسی می‌تواند پیامی را با **کلید عمومی** باب رمزگذاری کند.
- فقط باب می‌تواند آن را با **کلید خصوصی** خود رمزگشایی کند.
- این روش امکان **ارتباط امن بدون نیاز به تبادل کلید قبلی** را فراهم می‌کند.

---

## 🔄 رمزنگاری نامتقارن (Asymmetric)

- رمزنگاری کلید عمومی یک سیستم **نامتقارن** است:
  - یک کلید (عمومی) برای رمزگذاری.
  - کلید دیگر (خصوصی) برای رمزگشایی.
- تنها دارنده‌ی کلید خصوصی می‌تواند پیام‌ها را رمزگشایی کند.

---

## ⚙️ الگوریتم‌های محبوب: RSA و ECDSA

### RSA (ریوست–شامیر–ادلمن)

- بر پایه دشواری **تجزیه حاصل‌ضرب دو عدد اول بزرگ** است.
- ضرب دو عدد اول آسان است، ولی تجزیه معکوس بسیار سخت.
- امنیت آن به دشواری محاسباتی وابسته است (مرتبط با **مسئله P و NP**).
- در بسیاری از سیستم‌های رمزنگاری مدرن استفاده می‌شود.

### ECDSA (الگوریتم امضای دیجیتال منحنی بیضوی)

- از **منحنی‌های بیضوی** برای رمزنگاری استفاده می‌کند.
- با **کلیدهایی کوچک‌تر نسبت به RSA** امنیت مشابهی فراهم می‌کند.
- در بیت‌کوین و بسیاری از رمزارزها استفاده می‌شود (مثلاً منحنی secp256k1).
- به دلیل کارایی بالا و امنیت قوی، محبوبیت زیادی دارد.

---

## 📚 جمع‌بندی

- رمزنگاری از روش‌های ساده‌ی مبتنی بر کلید محرمانه به **سیستم‌های نامتقارن کلید عمومی** تکامل یافته است.
- رمزنگاری کلید عمومی، مشکل **ارتباط امن بدون تبادل قبلی کلید** را حل می‌کند.
- امضاهای دیجیتال، **اثبات منشأ و صحت پیام‌ها** را فراهم می‌کنند.
- RSA و ECDSA دو الگوریتم اصلی هستند که ارتباطات امن مدرن و فناوری بلاک‌چین را پشتیبانی می‌کنند.

---

## منابع

- [RFC 6979 - امضای دیجیتال قطعی ECDSA](https://datatracker.ietf.org/doc/html/rfc6979)
- [استانداردهای SECG - SEC 1 و SEC 2](https://www.secg.org/)
- [RFC 5639 - منحنی‌های Brainpool](https://datatracker.ietf.org/doc/html/rfc5639)

---

# منابع تکمیلی درباره امضاهای دیجیتال

در ادامه منابع مفیدی برای یادگیری بیشتر درباره امضاهای دیجیتال آورده شده‌اند. این منابع برای درک بهتر الگوریتم‌ها بسیار ارزشمند هستند.

---

## ECDSA

- **[Cloudflare درباره ECDSA](https://www.cloudflare.com/learning/ssl/what-is-ecdsa/)**  
  مقاله‌ای عالی درباره استفاده ECDSA در وب. برای درک بهتر HTTPS بسیار مفید است.

- **[ویکی‌پدیا - ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)**  
  اگرچه ریاضی‌محور است، اما برای درک عمیق‌تر الگوریتم مفید است.

- **[توضیح ساده ریاضی ECDSA](https://cryptobook.nakov.com/digital-signatures/ecdsa-sign-verify-messages)**  
  توضیحی شفاف و قابل فهم از ریاضیات پشت ECDSA.

---

## بیت‌کوین

- **[پارامترهای منحنی secp256k1](https://en.bitcoin.it/wiki/Secp256k1)**  
  منحنی secp256k1 در بیت‌کوین استفاده می‌شود؛ پارامترهای آن به‌گونه‌ای انتخاب شده‌اند که کمتر احتمال وجود درب پشتی در آن باشد.

- **[نمودار استخراج آدرس بیت‌کوین](https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses)**  
  برای درک نحوه استخراج آدرس از کلید عمومی بسیار مفید است.

- **[جزئیات فنی استخراج آدرس و چکسام](https://learnmeabitcoin.com/technical/address)**  
  نحوه استفاده بیت‌کوین از چکسام‌ها را توضیح می‌دهد.

- **[رمزگذاری Base58 در بیت‌کوین](https://en.bitcoin.it/wiki/Base58Check_encoding)**  
  بیت‌کوین برای حذف کاراکترهای اشتباه‌پذیر مانند صفر `0` و O بزرگ از Base58 استفاده می‌کند.

---

## تبادل کلید دیفی-هلمن (Diffie-Hellman)

- **[TLS و رمزنگاری ترکیبی](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/)**  
  دیفی-هلمن بخش مهمی از فرآیند TLS است و رمزنگاری نامتقارن را برای تبادل کلید به کار می‌برد.

- **[توضیح رنگی و ساده دیفی-هلمن (ویدیو)](https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/diffie-hellman-key-exchange-part-1)**  
  معرفی جذاب و قابل فهم از این الگوریتم.

- **[توضیح ریاضی دیفی-هلمن](https://crypto.stackexchange.com/questions/5577/diffie-hellman-key-exchange-intuition)**  
  نگاهی عمیق‌تر به ریاضیات پشت این پروتکل.

- **[ویدیو درباره منحنی‌های بیضوی](https://www.youtube.com/watch?v=NF1pwjL9-DE)**  
  برای درک بصری بهتر از منحنی‌های بیضوی بسیار مفید است.

---

## RSA

- **[ویکی‌پدیا - RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem))**  
  مرور فنی و جامع از الگوریتم RSA.

- **[کتاب رمزنگاری - توضیح RSA](https://cryptobook.nakov.com/asymmetric-key-ciphers/rsa-encryption-decryption)**  
  توضیح ساده‌ی RSA به زبان انگلیسی روان.

- **[ویدیوهای WooTube درباره RSA - [بخش ۱](https://www.youtube.com/watch?v=wXB-V_Keiu8) و [بخش ۲](https://www.youtube.com/watch?v=gs3MKXe4VM0)**  
  دو ویدیوی آموزشی بسیار خوب درباره ریاضی پشت RSA.

- **[درِ پشتی احتمالی RSA](https://arstechnica.com/information-technology/2013/09/nsa-paid-security-firm-10-million-to-implement-backdoored-crypto/)**  
  بحثی درباره آسیب‌پذیری‌ها و احتمال وجود درب پشتی در تاریخچه RSA.

---

> # تقلب‌نامه الگوریتم امضای دیجیتال بیضوی (ECDSA)

## 🔍 نمای کلی

ECDSA یک طرح امضای دیجیتال مبتنی بر رمزنگاری منحنی بیضوی (ECC) است که امضایی امن و کارآمد فراهم می‌کند.

- مبتنی بر **مسئله لگاریتم گسسته منحنی بیضوی (ECDLP)**
- استفاده از **منحنی‌های بیضوی روی میدان‌های محدود**
- امنیت معادل با RSA ولی با **اندازه کلید کوچکتر** و **محاسبات سریع‌تر**

---

## 🧠 مفاهیم کلیدی

- **منحنی بیضوی (EC)**: با معادله‌ای در فرم وایراست روی میدان محدود تعریف می‌شود.
- **نقطه مولد (G)**: نقطه‌ای از منحنی که برای ضرب اسکالر استفاده می‌شود.
- **مرتبه (n)**: تعداد نقاط در زیرگروهی که با G ایجاد می‌شود.
- **کلید خصوصی (privKey)**: عددی تصادفی در بازه `[1, n - 1]`
- **کلید عمومی (pubKey)**: نقطه‌ای روی منحنی برابر `privKey * G`

---

## 🔢 مثال منحنی: secp256k1

- در بیت‌کوین و اتریوم استفاده می‌شود.
- سطح امنیتی ۲۵۶ بیت

**پارامترها:**

```
مرتبه n:
115792089237316195423570985008687907852837564279074904382605163141518161494337

نقطه G:
x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
```

---

## 🔐 تولید کلید

1. یک عدد تصادفی `privKey` در `[1, n - 1]` تولید کن.
2. محاسبه `pubKey = privKey * G`

**فشرده‌سازی کلید عمومی:**
- فقط مختصات x + یک بیت توازن ذخیره می‌شود.
- حدود ۳۳ بایت برای secp256k1

---

## ✍️ امضا با ECDSA

### ورودی:
- پیام `msg`
- کلید خصوصی `privKey`

### خروجی:
- امضا `{r, s}`

### مراحل:
1. هش پیام:  
   ```h = hash(msg)```

2. عدد تصادفی `k ∈ [1, n - 1]` تولید کن  
   - (می‌توان از `k` قطعی طبق RFC 6979 استفاده کرد)

3. نقطه را محاسبه کن:  
   ```R = k * G```  
   ```r = R.x mod n```

4. اثبات امضا:  
   ```s = k⁻¹ * (h + r * privKey) mod n```

5. خروجی نهایی:  
   ```{r, s}```

---

## ✅ بررسی امضا

### ورودی:
- پیام `msg`
- امضا `{r, s}`
- کلید عمومی `pubKey`

### خروجی:
- بولی: `true` (معتبر) یا `false` (نامعتبر)

### مراحل:
1. هش پیام:  
   ```h = hash(msg)```

2. معکوس s:  
   ```s1 = s⁻¹ mod n```

3. بازیابی نقطه:  
   ```R' = (h * s1) * G + (r * s1) * pubKey```

4. مختصات x را بگیر:  
   ```r' = R'.x mod n```

5. بررسی اعتبار:  
   ```r' == r```

---

## 🔣 نحوه کار ریاضیاتی

### معادله امضا:
```
s = k⁻¹ * (h + r * privKey) mod n
```

### بازیابی در تأیید:
```
R' = (h + r * privKey) * s⁻¹ * G = k * G
```

### معتبر است اگر:
```
R'.x == r
```

---

## 📏 اندازه امضا

| منحنی      | اندازه کلید | اندازه امضا |
|------------|-------------|--------------|
| secp256k1  | ۲۵۶ بیت     | ۶۴ بایت     |
| secp521r1  | ۵۲۱ بیت     | ۱۳۲ بایت    |

---

## ♻️ بازیابی کلید عمومی

ECDSA امکان بازیابی کلید عمومی را از:
- امضا `{r, s}`
- پیام `msg`

### امضای توسعه‌یافته
- قالب: `{r, s, v}` (با شناسه بازیابی `v`)
- در اتریوم و بلاک‌چین‌ها کاربرد دارد

### مورد استفاده:
- صرفه‌جویی در پهنای باند و ذخیره‌سازی با حذف نیاز به ارسال کلید عمومی

---

## 🧾 خلاصه

| جزء           | توضیح                                           |
|---------------|------------------------------------------------|
| `privKey`     | عدد تصادفی در بازه `[1, n - 1]`                |
| `pubKey`      | نقطه روی EC: برابر با `privKey * G`            |
| `r`           | مختصات x از `R = k * G`                         |
| `s`           | اثبات امضا با استفاده از کلید خصوصی و هش پیام |
| امضا          | `{r, s}` یا `{r, s, v}`                         |
| مثال منحنی    | secp256k1                                       |

---

---
# راهنمای خلاصه تبادل کلید دیفی-هلمن (DHKE)

تبادل کلید دیفی-هلمن (DHKE) روشی برای تبادل امن کلیدهای رمزنگاری از طریق یک کانال عمومی است. این روش به دو طرف امکان می‌دهد تا یک راز مشترک را به صورت مشترک ایجاد کنند که برای ارتباط رمزگذاری‌شده استفاده می‌شود.

---

## 🔑 مفاهیم کلیدی

- **تبادل کلید نامتقارن**: استفاده از کلیدهای عمومی و خصوصی.
- **استفاده از کلید متقارن**: راز مشترک ایجادشده برای رمزنگاری متقارن به کار می‌رود.
- **امنیت بر اساس**: مسئله لگاریتم گسسته (که حل آن سخت است).

---

## 📚 اصطلاحات

- `p`: عدد اول بزرگ (عمومی).
- `g`: یک ریشه اولیه مدولو `p` (عمومی).
- `a`: کلید خصوصی آلیس (مخفی).
- `b`: کلید خصوصی باب (مخفی).
- `A`: کلید عمومی آلیس = `g^a mod p`.
- `B`: کلید عمومی باب = `g^b mod p`.
- `s`: راز مشترک = `B^a mod p = A^b mod p`.

---

## 🔐 روند گام‌به‌گام

1. **تنظیمات عمومی**  
   هر دو طرف روی یک عدد اول بزرگ `p` و یک مولد `g` توافق می‌کنند.

2. **تولید کلید خصوصی**  
   هر طرف یک کلید خصوصی انتخاب می‌کند:  
   - آلیس: `a`  
   - باب: `b`

3. **محاسبه کلید عمومی**  
   هر طرف کلید عمومی خود را محاسبه و ارسال می‌کند:  
   - آلیس: `A = g^a mod p`  
   - باب: `B = g^b mod p`

4. **استخراج راز مشترک**  
   هر طرف راز مشترک را محاسبه می‌کند:  
   - آلیس: `s = B^a mod p`  
   - باب: `s = A^b mod p`

---

## 📄 مثال (با اعداد کوچک)

p = 23  
g = 5

آلیس:  
&nbsp;&nbsp;a = 6  
&nbsp;&nbsp;A = 5^6 mod 23 = 8

باب:  
&nbsp;&nbsp;b = 15  
&nbsp;&nbsp;B = 5^15 mod 23 = 2

تبادل:  
&nbsp;&nbsp;آلیس A = 8 را می‌فرستد  
&nbsp;&nbsp;باب B = 2 را می‌فرستد

راز مشترک:  
&nbsp;&nbsp;آلیس: s = 2^6 mod 23 = 18  
&nbsp;&nbsp;باب: s = 8^15 mod 23 = 18

هر دو راز مشترک مشابه `s = 18` را محاسبه می‌کنند.

---

## 🧠 امنیت

- **وابسته به**: سختی محاسبه لگاریتم‌های گسسته در میدان محدود.  
- **ناظر شنود**: مقادیر p، g، A و B را می‌بیند اما بدون حل مسئله لگاریتم گسسته نمی‌تواند راز مشترک را پیدا کند.

---

## 🔁 انواع

- **دیفی-هلمن با منحنی بیضوی (ECDH)**  
  استفاده از منحنی‌های بیضوی برای کارایی بهتر و کلیدهای کوچکتر.

- **دیفی-هلمن موقتی (DHE)**  
  استفاده از جفت کلیدهای تازه در هر جلسه برای تضمین محرمانگی کامل.

---

## 🧪 مثال پایتون

import random

def diffie_hellman(p, g):  
&nbsp;&nbsp;a = random.randint(1, p - 2)  
&nbsp;&nbsp;b = random.randint(1, p - 2)

&nbsp;&nbsp;A = pow(g, a, p)  
&nbsp;&nbsp;B = pow(g, b, p)

&nbsp;&nbsp;s_A = pow(B, a, p)  
&nbsp;&nbsp;s_B = pow(A, b, p)

&nbsp;&nbsp;assert s_A == s_B  
&nbsp;&nbsp;return s_A

shared_secret = diffie_hellman(23, 5)  
print("راز مشترک:", shared_secret)

---

## 🛡️ کاربردها

- HTTPS (TLS)  
- VPN  
- برنامه‌های پیام‌رسان (مثل Signal)  
- اشتراک فایل امن

---

## 📎 منابع

- [ویکی‌پدیا: تبادل کلید دیفی-هلمن](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)  
- [ویدیوی خان آکادمی](https://www.khanacademy.org/computing/computer-science/cryptography/modern-crypt/v/diffie-hellman-key-exchange-part-1)  
- [RFC 2631](https://datatracker.ietf.org/doc/html/rfc2631)

---

# خلاصه سیستم رمزنگاری RSA

سیستم رمزنگاری RSA یک الگوریتم رمزنگاری نامتقارن است که بر پایه سختی ریاضی تجزیه اعداد صحیح بزرگ ساخته شده است. این الگوریتم به طور گسترده برای انتقال داده‌های امن استفاده می‌شود.

---

## 🔐 مفاهیم کلیدی

- **رمزنگاری نامتقارن**: استفاده از کلید عمومی برای رمزنگاری و کلید خصوصی برای رمزگشایی.
- **بر اساس**: سختی تجزیه حاصل‌ضرب دو عدد اول بزرگ.
- **کاربردها**: ارتباط امن، امضای دیجیتال، تبادل کلید.

---

## 📚 اصطلاحات

- `p`، `q`: دو عدد اول بزرگ و متمایز.
- `n`: مدولوس، `n = p * q`.
- `φ(n)`: تابع اویلر، `φ(n) = (p-1)(q-1)`.
- `e`: نمای عمومی به گونه‌ای که `1 < e < φ(n)` و `gcd(e, φ(n)) = 1`.
- `d`: نمای خصوصی، `d ≡ e⁻¹ mod φ(n)`.
- `m`: پیام اصلی (به صورت عدد).
- `c`: پیام رمز شده.

---

## 🔧 تولید کلید

1. انتخاب دو عدد اول بزرگ: `p` و `q`.
2. محاسبه `n = p * q`.
3. محاسبه `φ(n) = (p - 1)(q - 1)`.
4. انتخاب نمای عمومی `e` به گونه‌ای که `gcd(e, φ(n)) = 1`.
5. محاسبه نمای خصوصی `d` به عنوان معکوس مدولاری `e` نسبت به `φ(n)`.

کلید عمومی: `(n, e)`  
کلید خصوصی: `(n, d)`

---

## 🔒 رمزنگاری و رمزگشایی

- **رمزنگاری**  
  برای رمزنگاری پیام `m` با کلید عمومی `(n, e)`:
  
  (c = m^e mod n)

- **رمزگشایی**  
  برای رمزگشایی پیام رمز شده `c` با کلید خصوصی `(n, d)`:
  
  (m = c^d mod n)

---

## 📄 مثال (با اعداد کوچک)

(p = 61  
q = 53  
n = p * q = 3233  
φ(n) = (p-1)*(q-1) = 3120  
e = 17  
d = 2753 (چون 17 * 2753 ≡ 1 mod 3120)

کلید عمومی: (3233, 17)  
کلید خصوصی: (3233, 2753)

پیام: m = 65  
رمزنگاری: c = 65^17 mod 3233 = 2790  
رمزگشایی: m = 2790^2753 mod 3233 = 65)

---

## 🧪 مثال پایتون

(from Crypto.Util.number import getPrime, inverse  
import random

def generate_rsa_keys(bits=512):  
    p = getPrime(bits)  
    q = getPrime(bits)  
    n = p * q  
    phi = (p - 1) * (q - 1)  
    e = 65537  
    d = inverse(e, phi)  
    return (n, e), (n, d)

def encrypt(m, pubkey):  
    n, e = pubkey  
    return pow(m, e, n)

def decrypt(c, privkey):  
    n, d = privkey  
    return pow(c, d, n)

pub, priv = generate_rsa_keys()  
message = 42  
cipher = encrypt(message, pub)  
plain = decrypt(cipher, priv)  
print("Original:", message)  
print("Encrypted:", cipher)  
print("Decrypted:", plain))

---

## 🛡️ امنیت

- **امنیت مبتنی بر**: سختی تجزیه اعداد بزرگ.  
- **اندازه کلید**: معمولاً 2048 یا 3072 بیت.  
- **آسیب‌پذیری‌ها**:  
  - تولید عدد تصادفی ضعیف  
  - استفاده از `e` کوچک بدون پدینگ (مثلاً RSA کتاب درسی)  
  - حملات زمان‌بندی و کانال جانبی

---

## 📎 کاربردها

- SSL/TLS (HTTPS)  
- PGP/GPG  
- امضای دیجیتال  
- تبادل کلید امن

---

## 🧠 بهترین روش‌ها

- استفاده از طرح‌های پدینگ مانند OAEP یا PKCS#1 v1.5.  
- اجتناب از رمزنگاری پیام‌های بزرگ به طور مستقیم با RSA.  
- استفاده از رمزنگاری ترکیبی (RSA + AES).  
- تعویض دوره‌ای کلیدها.

---

## 📘 منابع

- [ویکی‌پدیا: RSA (رمزنگاری)](https://en.wikipedia.org/wiki/RSA_(cryptosystem))  
- [کتاب رمزنگاری Boneh & Shoup](https://cryptobook.us/)  
- [ویدئو ریاضی RSA بخش 1](https://www.youtube.com/watch?v=wXB-V_Keiu8)  
- [ویدئو ریاضی RSA بخش 2](https://www.youtube.com/watch?v=pu4cLHSXoLY)

---

# اثبات کار و ماینینگ

شبکه‌های بلاک‌چین مانند اتریوم، پایگاه‌داده‌های توزیع‌شده و غیرمتمرکزی هستند که از چندین گره (کامپیوترهایی که پروتکل را اجرا می‌کنند) تشکیل شده‌اند.

---

## 🤔 مشکل هماهنگی

در سیستم‌های غیرمتمرکز، چند سؤال کلیدی مطرح می‌شود:

- چگونه همه گره‌ها روی وضعیت فعلی و آینده حساب‌ها و تعاملات قراردادها توافق می‌کنند؟
- چه کسی اجازه دارد تراکنش‌های جدید را به بلاک‌چین اضافه کند؟
- چگونه می‌توان اطمینان حاصل کرد که بلاک‌های اضافه شده معتبر هستند؟
- همه این‌ها چگونه بدون یک مرجع مرکزی هماهنگ می‌شود؟

👉 پاسخ: **مکانیسم‌های اجماع**

---

## 🧠 مکانیسم‌های اجماع

**اجماع** یعنی رسیدن به توافق کلی. در بلاک‌چین، اجماع یعنی بیش از ۵۱٪ گره‌ها روی وضعیت جهانی شبکه توافق کنند.

مکانیسم‌های اجماع مجموعه قوانینی هستند که بلاک‌چین‌های غیرمتمرکز برای هماهنگی و اعتبارسنجی تراکنش‌ها از آن‌ها پیروی می‌کنند. این مکانیسم‌ها قابل تعویض هستند و شبکه‌های مختلف از مکانیسم‌های متفاوتی مانند اثبات سهام و اثبات کار استفاده می‌کنند.

### 🔑 قوانین در اثبات کار (PoW)

- ❌ هیچ خرج دوگانه‌ای پذیرفته نمی‌شود.
- 🔗 **بلندترین زنجیره (بر اساس کار انجام شده)** زنجیره معتبر است — که به آن **اجماع ناکاموتو** می‌گویند.

---

## ⛏️ اثبات کار (PoW)

اثبات کار مکانیسم اجماعی است که:

- اطمینان حاصل می‌کند که روی موجودی‌ها و ترتیب تراکنش‌ها توافق شده است.
- خرج دوگانه را جلوگیری می‌کند.
- امنیت را از طریق تلاش محاسباتی فراهم می‌کند.

### چگونه کار می‌کند:

ماینرها (گره‌های ویژه) با حل یک مسئله محاسباتی سعی می‌کنند بلاک‌های جدید بسازند. "اثبات" انجام کار، خروجی هش معتبری است که پیدا کردن آن سخت اما تأییدش آسان است.

---

## 🏗️ ماینینگ چیست؟

**ماینینگ** = فرایند تولید یک بلاک معتبر برای اضافه شدن به زنجیره.

اگرچه اصطلاح ماینینگ از استخراج طلا گرفته شده (به دلیل مصرف بالای منابع)، در واقع یعنی:

> رقابت برای حل یک معمای رمزنگاری برای ایمن‌سازی شبکه و دریافت پاداش.

---

## ⚙️ چگونه ماینینگ PoW کار می‌کند

برای ماین کردن یک بلاک:

1. جمع‌آوری:
   - هدر بلاک قبلی
   - تراکنش‌های معلق (مِم‌پول)
2. اضافه کردن یک مقدار `nonce` (شروع از ۰)
3. هش کردن ترکیب (هدر + تراکنش‌ها + nonce)
4. مقایسه هش با **سختی هدف**
   - اگر `hash < target` بود، بلاک معتبر است
   - در غیر این صورت، nonce را افزایش داده و تکرار می‌کنیم

💡 این فرایند میلیون‌ها بار در ثانیه توسط ماینرها در سراسر جهان تکرار می‌شود.

---

## 🔢 سختی هدف

**سختی هدف** میزان سختی یافتن یک هش معتبر را مشخص می‌کند.

مثال (بیت‌کوین):  
یک هش معتبر ممکن است شبیه این باشد:  
(000000000000000000043f43161dc56a08ffd0727df1516c987f7b187f5194c6)

### هش‌های SHA-256

- SHA-256 خروجی‌های هگزادسیمال تولید می‌کند (اعداد ۰-۹ و حروف a-f).
- ۱ صفر پیشرو ≈ ۱۶ تلاش  
- ۲ صفر پیشرو ≈ ۲۵۶ تلاش  
- ۱۹ صفر پیشرو ≈ ۷۵ کادریلیون تلاش (7.55×10⁴⁶)

هر صفر پیشرو اضافه، میانگین تلاش‌ها را به صورت نمایی افزایش می‌دهد.

---

## 📜 شبه‌کد الگوریتم ماینینگ

(while True:  
 data = prev_block_header + new_transactions  
 nonce = 0  
 while True:  
  hash = SHA256(data + nonce)  
  if hash < target_difficulty:  
   broadcast new block  
   break  
  nonce += 1)

---

## 💰 چرا ماینرها این کار را انجام می‌دهند؟

ماینرها منابع واقعی مصرف می‌کنند:

- برق  
- سخت‌افزار تخصصی (ASIC، GPU)

در عوض پاداش می‌گیرند:

- پاداش بلاک (سکه‌های تازه ضرب شده)  
- کارمزد تراکنش‌ها

💡 این انگیزه تضمین می‌کند که ماینرها شبکه را ایمن نگه دارند و قوانین را رعایت کنند.

---

## 🛡️ امنیت شبکه از طریق PoW

- نیاز به کار محاسباتی حملات را پرهزینه می‌کند.  
- بلاک‌های نامعتبر توسط گره‌ها رد می‌شوند.  
- پیروی اکثریت از اجماع = دفترکل امن و قابل اعتماد.

---

## ✅ خلاصه

- **اثبات کار** تضمین می‌کند که شرکت‌کنندگان بلاک‌چین بدون نیاز به مرجع مرکزی قوانین توافق شده را دنبال کنند.  
- **ماینینگ** فرایند ایجاد و اعتبارسنجی بلاک‌ها با حل معماهای هش است.  
- سیستم توسط **سختی، تأیید و انگیزه‌ها** امن می‌شود.

شبکه‌های PoW مانند بیت‌کوین بر ماینرها تکیه دارند تا زنجیره را ایمن نگه دارند، تراکنش‌ها را اعتبارسنجی کنند و غیرمتمرکز بودن را حفظ کنند — همه از طریق تلاش محاسباتی.

---

# 🧠 خلاصه اثبات کار و ماینینگ

## 🧩 اثبات کار چیست؟

اثبات کار (PoW) یک **مکانیسم اجماع** است که اجازه می‌دهد شبکه‌های غیرمتمرکزی مانند بیت‌کوین (و قبلاً اتریوم) روی وضعیت بلاک‌چین **بدون نیاز به مرجع مرکزی** توافق کنند.

### اهداف PoW:
- جلوگیری از **خرج دوگانه**  
- اطمینان از **اعتبار** بلاک‌ها  
- حفظ **توافق** بین گره‌ها در شبکه غیرمتمرکز

---

## 🌐 گره‌های بلاک‌چین

- شبکه‌های بلاک‌چین پایگاه‌داده‌های **توزیع‌شده و غیرمتمرکز** هستند  
- هر گره یک کامپیوتر شرکت‌کننده در شبکه است  
- گره‌ها باید روی:  
 - موجودی‌های فعلی و آینده حساب‌ها  
 - ترتیب و **اعتبار تراکنش‌ها** توافق کنند

---

## 🔧 مکانیسم‌های اجماع

> **اجماع = توافق کلی**

- در بلاک‌چین، اجماع یعنی **۵۱٪ یا بیشتر** گره‌ها روی وضعیت جهانی توافق کنند  
- **قوانین مشخص می‌کنند چه چیزی معتبر است**  
- PoW یکی از مکانیسم‌های اجماع است (یکی دیگر اثبات سهام است)

### قوانین اصلی PoW:
- ❌ خرج دوگانه غیرمجاز است  
- 📏 **بلندترین زنجیره** (با بیشترین کار تجمعی) زنجیره معتبر است  
 → این به نام **اجماع ناکاموتو** شناخته می‌شود

---

## ⛏️ ماینینگ چیست؟

ماینینگ فرایند **افزودن بلاک‌های جدید** تراکنش‌های معتبر به بلاک‌چین است.

- ماینینگ = "کار" واقعی در اثبات کار  
- ماینرها گره‌هایی هستند که نرم‌افزار ماینینگ اجرا می‌کنند  
- ماینرها:  
 - تراکنش‌های معتبر را انتخاب می‌کنند  
 - سعی می‌کنند **یک معمای رمزنگاری را حل کنند**  
 - **اثبات کار** خود را ارائه می‌دهند  
 - در صورت موفقیت پاداش می‌گیرند

---

## 🔐 اثبات کار به زبان ساده

ماینرها باید هشی پیدا کنند که سختی هدف را برآورده کند:

مثال هش معتبر:  
**000000000000000000043f43161dc56a08ffd0727df1516c987f7b187f5194c6**

- این هش **۱۹ صفر پیشرو** دارد (یافتن آن بسیار سخت است!)  
- هش باید:  
 - از داده‌های معتبر (هدر بلاک قبلی + تراکنش‌ها) تولید شده باشد  
 - کمتر از سختی هدف فعلی باشد

---

## 🔁 هشینگ و سختی

- بیت‌کوین و اتریوم (در دوره PoW) از تابع هش **SHA-256** استفاده می‌کنند  
- خروجی به صورت **هگزادسیمال** است → ۱۶ حالت برای هر رقم (۰-۹ و a-f)

### مثال:  
- ۱ صفر پیشرو → میانگین ۱۶ تلاش  
- ۲ صفر پیشرو → ۲۵۶ تلاش (۱۶×۱۶)  
- ۱۹ صفر پیشرو → ~۷۵ کادریلیون تلاش به طور میانگین

---

## 🧮 الگوریتم ماینینگ PoW

1. 📦 گرفتن هدر بلاک فعلی + تراکنش‌های ممپول  
2. ➕ اضافه کردن یک **nonce** (شروع با ۰)  
3. 🔁 هش کردن داده‌ها  
4. 🔍 مقایسه هش با **سختی هدف**  
5. ✅ اگر هش < هدف → معما حل شده → بلاک جدید اضافه می‌شود  
6. ❌ در غیر این صورت → nonce افزایش و تکرار

---

## 🛡️ چرا PoW شبکه را امن می‌کند؟

- ماینرها باید **منابع واقعی** (برق، زمان، سخت‌افزار) مصرف کنند  
- هیچ راه میان‌بری وجود ندارد — تقلب بسیار پرهزینه است  
- تا زمانی که اکثریت قوانین را رعایت کنند، شبکه:  
 - امن  
 - معتبر  
 - قابل اعتماد می‌ماند

---

## 🎁 انگیزه ماینرها

ماینرها به خاطر:

- انجام کار  
- ایمن‌سازی شبکه  
- افزودن بلاک‌های معتبر

پاداش **ارز دیجیتال** می‌گیرند.

این سیستم پاداش انگیزه‌ها را هم‌راستا می‌کند و شبکه را امن نگه می‌دارد.

---

## ✅ نتیجه‌گیری

اثبات کار با **مصرف انرژی** و **تلاش محاسباتی** تضمین می‌کند که شبکه به اجماع برسد.

> ماینرها باید یک **خروجی هش معتبر** ارائه دهند تا اثبات کنند کاری انجام داده‌اند برای گسترش بلاک‌چین.

تا وقتی که بیشتر ماینرها صادق باشند، بلاک‌چین **تغییرناپذیر**، **امن** و **غیرمتمرکز** باقی می‌ماند.

---


# 🔐 خلاصه هشینگ و اثبات کار (Proof of Work)

## 📌 اثبات کار چیست؟

**اثبات کار (Proof of Work یا PoW)** مکانیزمی است که کامپیوترها را ملزم می‌کند مسائل **محاسباتی دشوار** را حل کنند تا کاری انجام شود — مثل ارسال پیام یا اضافه کردن یک بلاک به بلاکچین.

---

## 🧠 چرا اثبات کار مهم است؟

- 🌐 امنیت شبکه‌های غیرمتمرکز مثل بیت‌کوین  
- 🚫 جلوگیری از ارسال هرزنامه و سوءاستفاده  
- 💰 تشویق مشارکت از طریق پاداش‌های استخراج  
- 🛡️ سخت کردن تغییر بلاکچین به لحاظ محاسباتی  

---

## 💡 ریشه‌های اثبات کار

اثبات کار ابتدا به عنوان روشی برای مقابله با **هرزنامه‌های ایمیلی** مطرح شد که فرستنده باید قبل از ارسال پیام، یک مسئله محاسباتی کوچک را حل می‌کرد.

### مثال: پیدا کردن هش با شروع `555`

<pre>
sha256("0");      // 5feceb...
sha256("1");      // 6b86b2...
sha256("2");      // d4735e...
// ادامه حدس زدن...
sha256("5118");   // 555850... ✅ پیدا شد!
</pre>

- یافتن دشوار  
- تأیید آسان  
- با افزایش تعداد کاراکترهای شروع (مثلاً `5555`، `55555` و...) دشواری به‌طور نمایی افزایش می‌یابد

---

## 🧾 کاربرد: ضد هرزنامه

ارسال هر پیام را از نظر محاسباتی هزینه‌بر کنید.

اگر کاربری بخواهد ایمیل ارسال کند، باید هش ترکیبی از موارد زیر را بیابد:

- **پیام**  
- **آدرس گیرنده**  
- یک **نونس (nonce)**  

### مثال:

<pre>
sha256("Hi Grandma! coolgrandma555@hotmail.com 0");   // f2d9e2...
sha256("Hi Grandma! coolgrandma555@hotmail.com 1");   // 4ee36e...
sha256("Hi Grandma! coolgrandma555@hotmail.com 2");   // c25e5c...
// ...
sha256("Hi Grandma! coolgrandma555@hotmail.com 424"); // 5552ab... ✅
</pre>

- 🧑 تلاش یک‌باره برای فرستنده  
- 🛑 پرهزینه برای ارسال‌کنندگان هرزنامه در مقیاس بزرگ

---

## 🔁 نونس چیست؟

- **نونس** عددی است که فقط یک بار استفاده می‌شود تا ورودی را تغییر دهد  
- با افزایش نونس، هش‌های مختلفی تولید می‌شود  
- برای حدس زدن هش درست کاربرد دارد  
- در اثبات کار و استخراج اهمیت حیاتی دارد

---

## ⚙️ بیت‌کوین چگونه اثبات کار را استفاده می‌کند

بیت‌کوین از PoW برای **امنیت شبکه** و تأیید بلاک‌ها بهره می‌برد.

### روند:

1. ⛏️ استخراج‌کنندگان تراکنش‌های تأییدنشده را جمع‌آوری می‌کنند  
2. 🧱 یک بلاک کاندید می‌سازند  
3. 🔄 یک نونس به داده‌های بلاک اضافه می‌کنند  
4. 🔐 هدر بلاک را هش می‌کنند  
5. ✅ بررسی می‌کنند آیا هش کمتر از حد آستانه هدف است یا خیر  
6. 🪙 اگر موفق، بلاک را به بلاکچین اضافه و پاداش دریافت می‌کنند  
7. 🔁 در غیر این صورت، نونس جدید را امتحان می‌کنند و تکرار می‌کنند  

---

## 🛡️ چرا این روش امن است؟

- هزاران نود برای حل اثبات کار رقابت می‌کنند  
- اولین کسی که موفق شود، **بلاک بعدی را اضافه می‌کند**  
- برای حمله به شبکه باید بیش از نیمی از قدرت هش کل شبکه را داشته باشید (**حمله ۵۱٪**)

### حتی با کنترل ۵۱٪:

- می‌توانید تراکنش‌ها را به تأخیر بیندازید یا ترتیبشان را تغییر دهید  
- اما **نمی‌توانید بخش‌های بزرگی از تاریخچه را به راحتی بازنویسی کنید**  
- هزینه بسیار بالایی دارد و قابل تشخیص است

---

## 🧠 خلاصه

- **PoW** = مکانیزمی مبتنی بر تلاش برای تضمین عدالت و جلوگیری از سوءاستفاده  
- در **بیت‌کوین** برای امنیت تراکنش‌ها و بلاک‌ها استفاده می‌شود  
- شامل **هشینگ** و **نونس** است  
- شبکه‌ها را **مقاوم**، **شفاف** و **ضد دستکاری** می‌کند  
- حملات ممکن است ولی به دلیل هزینه و سختی بالا، **غیرعملی** هستند

---

# 📘 منابع تکمیلی درباره اثبات کار

---

## 🕰️ تاریخچه اثبات کار

### آدام بک و هَش‌کش (HashCash)  
- **HashCash** توسط **آدام بک** به عنوان روشی برای جلوگیری از هرزنامه ایمیلی پیشنهاد شد.  
- فرستنده باید هشی را محاسبه می‌کرد که شرایط خاصی را داشته باشد، که باعث می‌شد اسپم کردن پرهزینه و ناکارآمد شود.

### مشارکت سایفراپانک‌ها (Cypherpunk)  
- از طریق **لیست ایمیل سایفراپانک** به اشتراک گذاشته شد و الهام‌بخش توسعه‌های بعدی بود:

#### هال فینی: اثبات کار قابل استفاده مجدد  
- مفهوم **اثبات کار قابل استفاده مجدد (RPOW)** را گسترش داد.  
- اجازه می‌داد اثبات کار به صورت غیرمتمرکز منتقل و مجدداً استفاده شود.

#### وی دای: بی‌مانی (B-Money)  
- سیستم نظری ارز دیجیتال **B-Money** را پیشنهاد کرد.  
- بر مبنای مفهوم اثبات کار از HashCash بود.

---

## ⛏️ استخراج بیت‌کوین

### نقش استخراج  
- بیت‌کوین از **اثبات کار** به عنوان روش غیرمتمرکز برای تأیید تراکنش‌ها استفاده می‌کند.  
- **استخراج** رقابت برای حل پازل‌های محاسباتی جهت اضافه کردن بلاک به بلاکچین است.

### ویژگی‌های استخراج  
- بلاک‌ها تقریباً هر ۱۰ دقیقه استخراج می‌شوند.  
- این زمان ممکن است به دلیل کشف هش تصادفی کمی تغییر کند.

### تنظیم سختی  
- **سختی هدف** هر ۲۰۱۶ بلاک (حدود دو هفته) تغییر می‌کند.  
- این تنظیم باعث می‌شود تولید بلاک به طور متوسط هر ۱۰ دقیقه باقی بماند، صرف‌نظر از قدرت هش کل شبکه.  
- با افزایش تعداد استخراج‌کنندگان، سختی افزایش می‌یابد.  
- با کاهش تعداد، سختی کم می‌شود.

---

## 🧑‍🤝‍🧑 استخرهای استخراج

### استخر استخراج چیست؟  
- گروهی از استخراج‌کنندگان که قدرت هش خود را ترکیب می‌کنند.  
- پاداش‌ها به نسبت کاری که انجام داده‌اند تقسیم می‌شود.  
- باعث دریافت پاداش‌های کوچک‌تر ولی مکررتر می‌شود.

### چرا از استخرها استفاده کنیم؟  
- کاهش نوسان پرداخت‌ها.  
- درآمد قابل پیش‌بینی و پایدارتر نسبت به استخراج انفرادی.  
- مناسب استخراج‌کنندگانی با سخت‌افزار کم‌توان‌تر.

### اطلاعات بیشتر  
- 📌 میزان پاداش بیت‌کوین فعلی را [اینجا](https://www.blockchain.com/charts/coinbase-size) ببینید.  
- 📊 مقایسه جامع استخرهای استخراج را در [این سند](https://en.bitcoin.it/wiki/Comparison_of_mining_pools) مطالعه کنید.

---

# ساختار بلاکچین – خلاصه به سبک Cheatsheet

## تعریف بلاکچین
- بلاکچین یک پایگاه‌داده توزیع‌شده شامل زنجیره‌ای از بلاک‌های تأیید شده است.
- هر بلاک داده‌هایی مانند تراکنش‌ها را در خود دارد و با بلاک قبلی به‌صورت رمزنگاری‌شده مرتبط است.

## معماری بلاکچین
- بلاکچین هم توزیع‌شده (distributed) و هم غیرمتمرکز (decentralized) است.
- نود (Node): هر رایانه‌ای که نسخه‌ای از بلاکچین را نگه می‌دارد و در فرآیند تأیید مشارکت دارد.
- در شبکه همتا‌به‌همتا (P2P): هیچ سرور مرکزی‌ای وجود ندارد. همه نودها با هم برابرند.

## اجماع (Consensus)
- شبکه باید روی معتبر بودن داده‌ها به توافق برسد.
- مثال: بیت‌کوین از الگوریتم اثبات کار (Proof-of-Work) استفاده می‌کند.
- این مسأله مربوط به "مشکل ژنرال‌های بیزانسی" در علوم رایانه است.

## دمو بلاکچین
- بلاکچین با یک بلاک اولیه (Genesis Block) شروع می‌شود که شماره آن 0 است.

## اجزای یک بلاک
- index: موقعیت بلاک در زنجیره
- timestamp: زمان ایجاد بلاک (معمولاً به‌صورت UNIX)
- previous hash: هش بلاک قبلی
- data: داده‌های بلاک (مثلاً تراکنش‌ها)
- nonce: عددی برای یافتن هش معتبر
- hash: خروجی تابع هش که نماینده دیجیتال بلاک است

### تابع هش
- فرمول کلی:
  f(index + previous hash + timestamp + data + nonce) = hash

### هش معتبر چیست؟
- هشی که با تعداد خاصی صفر در ابتدای آن شروع شود.
- مثال: هش معتبر در دمو باید با سه صفر شروع شود → سختی (Difficulty)

### ماینینگ
- فرآیند یافتن nonce مناسب برای تولید هش معتبر است.
- ماینر nonce را از 0 شروع کرده و آن را تا یافتن هش مناسب افزایش می‌دهد.

## یکپارچگی داده در بلاکچین
- تغییر داده‌ها باعث تغییر هش بلاک می‌شود → بلاک نامعتبر می‌شود.
- به‌دلیل اتصال رمزنگاری بلاک‌ها، تغییر یک بلاک نیازمند بازنویسی تمام بلاک‌های بعدی آن است.
- حمله به بلاکچین نیازمند قدرت محاسباتی عظیم و غیرعملی است.

## افزودن بلاک جدید
- شرایط لازم:
  - index جدید = index بلاک قبلی + 1
  - previous hash = hash بلاک قبلی
  - هش بلاک جدید معتبر باشد (مطابق سختی)
  - هش به‌درستی محاسبه شده باشد

## اعتبارسنجی در شبکه P2P
- همه نودها بلاک‌های جدید را بررسی و در صورت اعتبار، آن را به زنجیره خود اضافه می‌کنند.
- اجماع از طریق مشارکت همگانی تمام نودها به‌دست می‌آید.

## نتیجه‌گیری
- بلاکچین یک دیتابیس مقاوم در برابر دستکاری است که با ترکیب رمزنگاری، اجماع و ساختار زنجیره‌ای، یکپارچگی داده را حفظ می‌کند.

---




# ساختار بلاکچین – برگه تقلب

بلاکچین‌ها پایگاه‌داده‌های پیشرفته‌ای هستند که برای سیستم‌های غیرمتمرکز طراحی شده‌اند. بیایید مفاهیم کلیدی معماری بلاکچین و تفاوت آن با پایگاه‌داده‌های سنتی را بررسی کنیم.

---

## معماری بلاکچین

یک **بلاکچین** یک **پایگاه‌داده توزیع‌شده** است که از زنجیره‌ای از بلاک‌های اعتبارسنجی‌شده تشکیل شده است. هر بلاک:

- شامل داده‌های تراکنش است
- به‌صورت رمزنگاری‌شده به بلاک قبلی متصل است

این امر باعث ایجاد یک **"زنجیره"** از بلاک‌ها می‌شود — بنابراین، نام آن **بلاک‌چین** است.

### نودها (گره‌ها)

- نودها رایانه‌ها یا دستگاه‌هایی هستند که در شبکه بلاکچین شرکت دارند.
- هر نود یک نسخه کامل از بلاکچین را نگهداری می‌کند.
- هیچ نودی اقتدار مرکزی ندارد — همه به‌طور **برابر** عمل می‌کنند.
- این ساختار، یک شبکه **نظیر به نظیر (P2P)** ایجاد می‌کند.

---

## شبکه متمرکز در برابر شبکه نظیر به نظیر

### شبکه متمرکز

- یک سرور مرکزی وضعیت داده را نگه می‌دارد.
- همه مشتری‌ها (کلاینت‌ها) باید به این سرور اعتماد کنند.

### شبکه نظیر به نظیر

- هیچ سرور مرکزی وجود ندارد.
- هر نود یک نسخه کامل از داده را نگه می‌دارد.
- هر نود می‌تواند بلاک‌های جدید را اعتبارسنجی و پیشنهاد دهد.

---

## سازوکار اجماع

**سؤال:**  
نودهای توزیع‌شده چگونه بدون یک مرجع مرکزی روی اعتبار داده توافق می‌کنند؟

**پاسخ:**  
از **سازوکارهای اجماع** استفاده می‌کنند.

### مثال: بیت‌کوین

بیت‌کوین از **اثبات کار (PoW)** استفاده می‌کند. نودها (ماینرها) برای حل یک مسئله ریاضی رقابت می‌کنند. اولین نودی که آن را حل کند، اجازه دارد بلاک جدید را اضافه کند.

این روش، مشکل معروف **ژنرال‌های بیزانسی** را حل می‌کند — اطمینان از توافق در یک سیستم غیرمتمرکز با بازیگران احتمالی مخرب.

---

## دموی بلاکچین

بازدید از: [https://blockchaindemo.io](https://blockchaindemo.io)

این دمو فرآیند ساخت و ساختار بلاکچین را قدم‌به‌قدم نمایش می‌دهد.

---

## بلاک جنسیس (Genesis Block)

- **بلاک جنسیس** اولین بلاک در یک بلاکچین است.
- ویژگی‌های آن:
  - `index = 0`
  - `previous hash = "0"`

---

## ساختار بلاک

هر بلاک شامل موارد زیر است:

- `index`: موقعیت بلاک در زنجیره
- `timestamp`: زمان ایجاد (معمولاً به‌صورت زمان یونیکس)
- `previous hash`: هش بلاک قبلی
- `data`: محتوای بلاک (مثلاً تراکنش‌ها)
- `nonce`: عددی برای پیدا کردن هش معتبر
- `hash`: اثرانگشت دیجیتال بلاک (در داخل بلاک ذخیره نمی‌شود)

---

## تابع هش (Hashing Function)

تابع هش، داده‌های بلاک را می‌گیرد و یک اثرانگشت دیجیتال منحصر‌به‌فرد ایجاد می‌کند:

**f(index + previousHash + timestamp + data + nonce) = hash**

مثال:

f(0 + "0" + 1508270000000 + "Welcome to Blockchain Demo 2.0!" + 604)  
= 000dc75a315c77a1f9c98fb6247d03dd18ac52632d7dc6a9920261d8109b37cf

---

## هش معتبر (Valid Hash)

هش معتبر باید شرایط خاصی داشته باشد — معمولاً شامل تعداد مشخصی صفر در ابتدای هش است.

مثال:

- هش معتبر باید با `000` شروع شود
- تعداد صفرهای بیشتر = **سختی بیشتر (difficulty)**

### استخراج (Mining)

- ماینرها مقدار `nonce` را تغییر می‌دهند تا هش معتبری بیابند.
- این فرآیند محاسباتی بسیار سنگینی دارد و به آن **ماینینگ** می‌گویند.

---

## یکپارچگی داده (Data Integrity)

**سؤال:**  
چگونه بلاکچین‌ها تضمین می‌کنند که داده‌ها خراب یا دستکاری نمی‌شوند؟

**پاسخ:**  
چون هش هر بلاک وابسته به محتوای آن است، تغییر داده باعث تغییر هش می‌شود.

پیامدهای تغییر یک بلاک:

1. هش نامعتبر می‌شود (دیگر با سختی همخوانی ندارد).
2. بلاک‌های بعدی خراب می‌شوند، چون `previous hash` آن‌ها نادرست می‌شود.
3. مهاجم باید **تمام** بلاک‌های بعدی را دوباره ماین کند — که از نظر محاسباتی غیرممکن است.

مثال:

هش اولیه بلاک جنسیس:  
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f

هش تغییریافته:  
eb3e5df5eefceb8950e4a444507ce7df1cc534f54a5113f2792ab64830392db0

"مالوری" باید:

1. یک هش معتبر جدید برای بلاک تغییریافته پیدا کند.
2. هر بلاک بعدی را دوباره محاسبه و ماین کند.
3. همه این کارها را **سریع‌تر** از باقی شبکه انجام دهد.

حمله شکست می‌خورد. ✅ یکپارچگی داده حفظ می‌شود.

---

## افزودن بلاک جدید

برای افزودن یک بلاک جدید، باید شرایط زیر برقرار باشد:

1. `index` یک عدد بیشتر از بلاک قبلی باشد.
2. `previous hash` برابر هش بلاک قبلی باشد.
3. `hash` به‌درستی محاسبه شده باشد.
4. `hash` با سطح سختی مطابقت داشته باشد.

---

## اعتبارسنجی توسط همتایان (P2P Validation)

هر نود در شبکه P2P بلاک پیشنهادی جدید را اعتبارسنجی می‌کند.

- همه نودها از قوانین اجماع یکسان استفاده می‌کنند.
- اگر بلاک معتبر باشد، به نسخه محلی آن‌ها اضافه می‌شود.
- همه نسخه‌ها بدون نیاز به مرکز، هماهنگ باقی می‌مانند.

---

## نتیجه‌گیری

بلاکچین‌ها دارای ویژگی‌های زیر هستند:

- **غیرمتمرکز**
- **توزیع‌شده**
- **امن**
- **مقاوم در برابر دستکاری**

با استفاده از سازوکارهایی مانند اثبات کار و ساختار زنجیره‌ای، بلاکچین‌ها بدون نیاز به مدیر مرکزی، یکپارچگی داده را حفظ می‌کنند.

---
